#include <stdio.h>
#include <stdlib.h>
typedef unsigned char     elem_t;
typedef     unsigned short uint16_t;
typedef      short int16_t;
#define     QUEUE_MAX_SIZE      1024
#define     QUEUE_DEFAULT_SIZE	128

struct QUEUE {
	elem_t *Data;
	int16_t Front;
	int16_t Rear;
	int16_t Size;
};

enum QUEUE_STATE {
	QUEUE_OK,
	QUEUE_MALLOC_FAILED,
	QUEUE_EMPTY,
	QUEUE_FULL
};
typedef enum QUEUE_STATE queue_state_t;

struct QUEUE *QueueCreate(int16_t size) {
	struct QUEUE *qp = malloc(sizeof(struct QUEUE));
	if (qp == NULL)
		return NULL;

	size = (size > QUEUE_MAX_SIZE) ? QUEUE_MAX_SIZE : size;
	qp->Data = malloc((size + 1) * sizeof(elem_t));
	if (qp->Data == NULL)
		return NULL;

	qp->Front = qp->Rear = 0;
	qp->Size = size + 1;

	return qp;
}

int16_t QueueIsEmpty(struct QUEUE *q) {
	return (q->Front == q->Rear);
}

int16_t QueueIsFull(struct QUEUE *q) {
	return ((q->Rear + 1) % q->Size == q->Front);
}

queue_state_t DeQueue(struct QUEUE *q) {
	if (QueueIsEmpty(q))
		return QUEUE_EMPTY;

	q->Front = (q->Front + 1) % q->Size;

	return QUEUE_OK;
}

queue_state_t EnQueue(struct QUEUE *q, elem_t d) {
	if (QueueIsFull(q)) {
		DeQueue(q);  //队列满了的话丢掉历史数据
	}
	//	return QUEUE_FULL;
	q->Data[q->Rear] = d;
	q->Rear = (q->Rear + 1) % q->Size;

	return QUEUE_OK;
}



float OutQueue(struct QUEUE *q) {
	elem_t Outdata;

	if (QueueIsEmpty(q))
		return QUEUE_EMPTY;
	Outdata =  q->Data[(q->Front) % q->Size];
	q->Front = (q->Front + 1) % q->Size;

	return  Outdata;
}


int16_t QueueLength(struct QUEUE *q) {
	return ((q->Rear + q->Size - q->Front) % q->Size);
}
struct QUEUE *MViQueue;		///< 维护吸气潮气量的循环队列，用于计算吸气分钟通气量
// q->Front是老数据，q->Rear是新数据,Front比Rear小，出队Front索引增加，入队Rear索引增加


void queue_print(struct QUEUE *q) {
	int16_t i;
	for (i = 0; i < QueueLength(q); i++)
		printf("%x\t", q->Data[(q->Front + i) % q->Size]);
	printf("\n");
}

void QueueClear(struct QUEUE *q) {
	q->Front = q->Rear = 0;
}

void QueueFree(struct QUEUE **qp) {
	free((*qp)->Data);
	free(*qp);
}


float MovingAverageFilter(struct QUEUE *Queue, float in) {
	float       Sum = 0;
	uint16_t    i = 0;
	uint16_t    Len = 0;

	if (QueueIsFull(Queue)) {
		DeQueue(Queue);
	}
	EnQueue(Queue, in);

	Len = QueueLength(Queue);

	for (i = 0; i < Len; i++) {
		Sum += Queue->Data[(Queue->Front + i) % Queue->Size];
		//	printf("%f ", Queue->Data[(Queue->Front + i) % Queue->Size]);

		//	printf("Data[%x]:%x\n", i, Queue->Data[(Queue->Front + i) % Queue->Size]);
	}
	printf("\n ");
	return Sum /= Len;
}

float test1 = 0, test2 = 10, test3 = 0;
void check(struct QUEUE *q);
//unsigned char testchar[] = {0x11, 0x01, 0x03, 0x04, 0xF5, 0xC3, 0x40, 0x48, 0x08, 0x35, 0x36, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16};

unsigned char testchar[] = {0x11, 0x01, 0x03, 01, 0x03, 0x0C, 0x07, 0x0B, 0x26, 0xFC, 0x2A, 0x33, 0x28, 0x22, 0x4D, 0xFE,
                            0x53, 0x7C, 0xC7, 0x28, 0x35, 0x36, 0x16, 0x16, 0x16, 0x16, 0x16,
                            0x02, 0x03, 0x20, 0x00, 0x00, 0x25, 0xAE, 0x00, 0x00, 0x7F, 0x71, 0x25, 0xAE, 0x00, 0x00, 0x7F, 0x71, 0x00, 0x00,
                            0x41, 0x1A, 0x56, 0x6F, 0x42, 0x02, 0x80, 0x00, 0x56, 0x6F, 0x41, 0x1A, 0x80, 0x00, 0x42, 0x02, 0x11, 0x87, 0x88,
                            0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
                            0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
                            0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
                            0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16
                           };


//该代码用来实现对滑动队列testchar的帧检测
int main() {
	MViQueue = QueueCreate(1000);
	for (int i = 0; i < 100; i++)
		EnQueue(MViQueue, testchar[i]);

	for (int i = 0; i < 100; i++) {
		check(MViQueue);
		DeQueue(MViQueue);
	}





//	while (test2--) {
//		if (QueueIsFull(MViQueue)) {
//			DeQueue(MViQueue);
//		}
//		EnQueue(MViQueue, test2);
//		//	test1 = MovingAverageFilter(MViQueue, 22);
//		queue_print(MViQueue);
//
//	}

////

//////	while (test2--) {
//	EnQueue(MViQueue, 30);
//
//	printf("zhi:%x changdu:%d fro:%d rea:%d\n", test3, QueueLength(MViQueue), MViQueue->Front, MViQueue->Rear);
//
//
////	printf("zhi:%f changdu:%d\n", 10, QueueLength(MViQueue));
//
//	queue_print(MViQueue);
//
//	EnQueue(MViQueue, 22);
////	printf("zhi:%f changdu:%d\n", 22, QueueLength(MViQueue));
//	printf("zhi:%x changdu:%d fro:%d rea:%d\n", test3, QueueLength(MViQueue), MViQueue->Front, MViQueue->Rear);
//
//	queue_print(MViQueue);
//
//	EnQueue(MViQueue, 5);
////	printf("zhi:%f changdu:%d\n", 5, QueueLength(MViQueue));
//	printf("zhi:%x changdu:%d fro:%d rea:%d\n", test3, QueueLength(MViQueue), MViQueue->Front, MViQueue->Rear);
//
//	queue_print(MViQueue);
//
//	EnQueue(MViQueue, 8);
////	printf("zhi:%f changdu:%d\n", 8, QueueLength(MViQueue));
//	printf("zhi:%x changdu:%d fro:%d rea:%d\n", test3, QueueLength(MViQueue), MViQueue->Front, MViQueue->Rear);
//
//	queue_print(MViQueue);
//
//	EnQueue(MViQueue, 7);
////	printf("zhi:%f changdu:%d\n", 8, QueueLength(MViQueue));
//	printf("zhi:%x changdu:%d fro:%d rea:%d\n", test3, QueueLength(MViQueue), MViQueue->Front, MViQueue->Rear);
//
//	queue_print(MViQueue);
////	queue_print(MViQueue);
////	printf("ave:%f\n", test1);
////	queue_print(MViQueue);
//
//	test3 = OutQueue(MViQueue);
//	printf("zhi:%x changdu:%d fro:%d rea:%d\n", test3, QueueLength(MViQueue), MViQueue->Front, MViQueue->Rear);
//
//	queue_print(MViQueue);
//	test3 = OutQueue(MViQueue);
//	printf("zhi:%x changdu:%d fro:%d rea:%d\n", test3, QueueLength(MViQueue), MViQueue->Front, MViQueue->Rear);
//
//	queue_print(MViQueue);
//
//	EnQueue(MViQueue, 3);
////	printf("zhi:%f changdu:%d\n", 8, QueueLength(MViQueue));
//	printf("zhi:%x changdu:%d fro:%d rea:%d\n", test3, QueueLength(MViQueue), MViQueue->Front, MViQueue->Rear);
//
//	queue_print(MViQueue);
//
//	EnQueue(MViQueue, 2);
////	printf("zhi:%f changdu:%d\n", 8, QueueLength(MViQueue));
//	printf("zhi:%x changdu:%d fro:%d rea:%d\n", test3, QueueLength(MViQueue), MViQueue->Front, MViQueue->Rear);
//
//	queue_print(MViQueue);
//
//	EnQueue(MViQueue, 1);
////	printf("zhi:%f changdu:%d\n", 8, QueueLength(MViQueue));
//	printf("zhi:%x changdu:%d fro:%d rea:%d\n", test3, QueueLength(MViQueue), MViQueue->Front,   MViQueue->Size);
//
//	queue_print(MViQueue);

//	}

}


unsigned char auchCRCHi[ ] = {

	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00,

	0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1,

	0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,

	0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,

	0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01,

	0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,

	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80,

	0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,

	0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00,

	0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,

	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80,

	0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80,

	0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,

	0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00,

	0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,

	0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,

	0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,

	0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00,

	0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,

	0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40

};





unsigned char auchCRCLo[ ] = {

	0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,

	0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE,

	0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19,

	0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C,

	0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13,

	0xD3, 0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2,

	0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD,

	0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8,

	0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F,

	0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6,

	0x26, 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61,

	0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64,

	0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B,

	0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A,

	0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75,

	0xB5, 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70,

	0xB0, 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57,

	0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E,

	0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49,

	0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C,

	0x8C, 0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43,

	0x83, 0x41, 0x81, 0x80, 0x40

};



unsigned short CRC16ModBus(unsigned char *puchMsg, unsigned short usDataLen) {

	unsigned char uchCRCHi = 0xFF;

	unsigned char uchCRCLo = 0xFF;

	unsigned char uIndex;

	unsigned short i = 0;

	while (usDataLen-- > 0) {

		uIndex = (unsigned char)(uchCRCHi ^ puchMsg[i++]);

		uchCRCHi = (unsigned char)(uchCRCLo ^ auchCRCHi[uIndex]);

		uchCRCLo = auchCRCLo[uIndex];

	}

	return (unsigned short)(( unsigned short)uchCRCHi << 8 | uchCRCLo);

}

// q->Front是老数据，q->Rear是新数据,Front比Rear小，老数据出队Front索引增加，新数据入队Rear索引增加，Rear达到
//最大值后变为0


unsigned char modbustest[100], geshu = 0;
void check(struct QUEUE *q) {
	int16_t i;
	printf("当前队列中的剩余元素");
	for (i = 0; i < QueueLength(q); i++)
		printf("0x%x ", q->Data[(q->Front + i) % q->Size]);
//	printf("\n");

	if (QueueLength(q) > 10) {  //队列剩余数量足够
		if ((q->Data[(q->Front + 0) % q->Size]) >> 4 == 0
		        || q->Data[(q->Front + 0) % q->Size] >> 4 == 7) { //当前字节符合传感器地址
			if (q->Data[(q->Front + 1)] == 0x03) {
				if ( q->Data[(q->Front + 2)] < 33) { //MDOBUS数量符合:加个限制，别太离谱
					geshu = q->Data[(q->Front + 2)] + 5;
					for (i = 0; i < geshu ; i++) { //地址+读+数量+――――+2crc
						modbustest[i] = q->Data[(q->Front + i) % q->Size] ;    //将这段内存拷贝过去
					}
					if (CRC16ModBus(modbustest, geshu - 2) == (modbustest[geshu - 2] << 8 | modbustest[geshu - 1])) { //CRC校验是否正确
						printf("识别成功\n");
						for (i = 0; i < geshu - 1 ; i++) { //地址+读+数量+――――+2crc
							//	printf("0x%x ", modbustest[i]);
							DeQueue(MViQueue) ;
						}
						for (i = 0; i < geshu ; i++) { //地址+读+数量+――――+2crc
							//	printf("0x%x ", modbustest[i]);
							//	DeQueue(MViQueue);
						}


					} else {
						printf("crc fail:");
						for (i = 0; i < geshu ; i++) { //地址+读+数量+――――+2crc
							printf("0x%x ", modbustest[i]);
						}
						printf("\n");

					}

				} else {
					printf("modbus read shuliang fail\n");
				}

			} else {
				printf("下字节不是读\n");
			}
		} else {
			printf("不是modbus地址\n");
		}

	} else {
		printf("对列剩余数量不足\n");
	}



}





////思路，每一个字节都检测一次
//void check(   ) {






//判断队列长度是否够
//	//判断该字节是否为地址；
//	//判断该字节+1是否为03；
//	//判断该字节地址和读取数量是否对应；__
//	//判断CRC是否正确；
//
//}













